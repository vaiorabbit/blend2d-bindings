# Ruby-Blend2D : Yet another Blend2D wrapper for Ruby
#
# * https://github.com/vaiorabbit/blend2d-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'
require_relative 'blend2d_array'
require_relative 'blend2d_format'
require_relative 'blend2d_geometry'
require_relative 'blend2d_imagecodec'
require_relative 'blend2d_object'

module Blend2D
  extend FFI::Library
  # Define/Macro


  # Enum

  BL_IMAGE_INFO_FLAG_NO_FLAGS = 0
  BL_IMAGE_INFO_FLAG_PROGRESSIVE = 1
  BL_IMAGE_INFO_FLAG_FORCE_UINT = 4294967295
  BL_IMAGE_SCALE_FILTER_NONE = 0
  BL_IMAGE_SCALE_FILTER_NEAREST = 1
  BL_IMAGE_SCALE_FILTER_BILINEAR = 2
  BL_IMAGE_SCALE_FILTER_BICUBIC = 3
  BL_IMAGE_SCALE_FILTER_LANCZOS = 4
  BL_IMAGE_SCALE_FILTER_MAX_VALUE = 4
  BL_IMAGE_SCALE_FILTER_FORCE_UINT = 4294967295

  # Typedef

  typedef :int, :BLImageInfoFlags
  typedef :int, :BLImageScaleFilter

  # Struct

  class BLImageData < FFI::Struct
    layout(
      :pixelData, :pointer,
      :stride, :int64,
      :size, BLSizeI,
      :format, :uint,
      :flags, :uint,
    )
    def pixelData = self[:pixelData]
    def pixelData=(v) self[:pixelData] = v end
    def stride = self[:stride]
    def stride=(v) self[:stride] = v end
    def size = self[:size]
    def size=(v) self[:size] = v end
    def format = self[:format]
    def format=(v) self[:format] = v end
    def flags = self[:flags]
    def flags=(v) self[:flags] = v end
    def self.create_as(_pixelData_, _stride_, _size_, _format_, _flags_)
      instance = BLImageData.new
      instance[:pixelData] = _pixelData_
      instance[:stride] = _stride_
      instance[:size] = _size_
      instance[:format] = _format_
      instance[:flags] = _flags_
      instance
    end
  end

  class BLImageInfo < FFI::Struct
    layout(
      :size, BLSizeI,
      :density, BLSize,
      :flags, :uint,
      :depth, :ushort,
      :planeCount, :ushort,
      :frameCount, :ulong_long,
      :format, [:char, 16],
      :compression, [:char, 16],
    )
    def size = self[:size]
    def size=(v) self[:size] = v end
    def density = self[:density]
    def density=(v) self[:density] = v end
    def flags = self[:flags]
    def flags=(v) self[:flags] = v end
    def depth = self[:depth]
    def depth=(v) self[:depth] = v end
    def planeCount = self[:planeCount]
    def planeCount=(v) self[:planeCount] = v end
    def frameCount = self[:frameCount]
    def frameCount=(v) self[:frameCount] = v end
    def format = self[:format]
    def format=(v) self[:format] = v end
    def compression = self[:compression]
    def compression=(v) self[:compression] = v end
    def self.create_as(_size_, _density_, _flags_, _depth_, _planeCount_, _frameCount_, _format_, _compression_)
      instance = BLImageInfo.new
      instance[:size] = _size_
      instance[:density] = _density_
      instance[:flags] = _flags_
      instance[:depth] = _depth_
      instance[:planeCount] = _planeCount_
      instance[:frameCount] = _frameCount_
      instance[:format] = _format_
      instance[:compression] = _compression_
      instance
    end
  end

  class BLImageCore < FFI::Struct
    layout(
      :_d, BLObjectDetail,
    )
    def _d = self[:_d]
    def _d=(v) self[:_d] = v end
    def init() = blImageInit(self)
    def self.create()
      instance = BLImageCore.new
      blImageInit(instance)
      instance
    end
    def initMove(other) = blImageInitMove(self, other)
    def initWeak(other) = blImageInitWeak(self, other)
    def initAs(w, h, format) = blImageInitAs(self, w, h, format)
    def self.create_as(w, h, format)
      instance = BLImageCore.new
      blImageInitAs(instance, w, h, format)
      instance
    end
    def initAsFromData(w, h, format, pixelData, stride, accessFlags, destroyFunc, userData) = blImageInitAsFromData(self, w, h, format, pixelData, stride, accessFlags, destroyFunc, userData)
    def destroy() = blImageDestroy(self)
    def reset() = blImageReset(self)
    def assignMove(other) = blImageAssignMove(self, other)
    def assignWeak(other) = blImageAssignWeak(self, other)
    def assignDeep(other) = blImageAssignDeep(self, other)
    def create(w, h, format) = blImageCreate(self, w, h, format)
    def createFromData(w, h, format, pixelData, stride, accessFlags, destroyFunc, userData) = blImageCreateFromData(self, w, h, format, pixelData, stride, accessFlags, destroyFunc, userData)
    def getData(dataOut) = blImageGetData(self, dataOut)
    def makeMutable(dataOut) = blImageMakeMutable(self, dataOut)
    def convert(format) = blImageConvert(self, format)
    def equals(b) = blImageEquals(a, b)
    def scale(src, size, filter) = blImageScale(dst, src, size, filter)
    def readFromFile(fileName, codecs) = blImageReadFromFile(self, fileName, codecs)
    def readFromData(data, size, codecs) = blImageReadFromData(self, data, size, codecs)
    def writeToFile(fileName, codec) = blImageWriteToFile(self, fileName, codec)
    def writeToData(dst, codec) = blImageWriteToData(self, dst, codec)
  end

  class BLImageImpl < FFI::Struct
    layout(
      :pixelData, :pointer,
      :stride, :int64,
      :size, BLSizeI,
      :format, :uchar,
      :flags, :uchar,
      :depth, :ushort,
      :reserved, [:uchar, 4],
    )
    def pixelData = self[:pixelData]
    def pixelData=(v) self[:pixelData] = v end
    def stride = self[:stride]
    def stride=(v) self[:stride] = v end
    def size = self[:size]
    def size=(v) self[:size] = v end
    def format = self[:format]
    def format=(v) self[:format] = v end
    def flags = self[:flags]
    def flags=(v) self[:flags] = v end
    def depth = self[:depth]
    def depth=(v) self[:depth] = v end
    def reserved = self[:reserved]
    def reserved=(v) self[:reserved] = v end
    def self.create_as(_pixelData_, _stride_, _size_, _format_, _flags_, _depth_, _reserved_)
      instance = BLImageImpl.new
      instance[:pixelData] = _pixelData_
      instance[:stride] = _stride_
      instance[:size] = _size_
      instance[:format] = _format_
      instance[:flags] = _flags_
      instance[:depth] = _depth_
      instance[:reserved] = _reserved_
      instance
    end
  end


  # Function

  def self.setup_image_symbols(output_error = false)
    symbols = [
      :blImageInit,
      :blImageInitMove,
      :blImageInitWeak,
      :blImageInitAs,
      :blImageInitAsFromData,
      :blImageDestroy,
      :blImageReset,
      :blImageAssignMove,
      :blImageAssignWeak,
      :blImageAssignDeep,
      :blImageCreate,
      :blImageCreateFromData,
      :blImageGetData,
      :blImageMakeMutable,
      :blImageConvert,
      :blImageEquals,
      :blImageScale,
      :blImageReadFromFile,
      :blImageReadFromData,
      :blImageWriteToFile,
      :blImageWriteToData,
    ]
    apis = {
      :blImageInit => :blImageInit,
      :blImageInitMove => :blImageInitMove,
      :blImageInitWeak => :blImageInitWeak,
      :blImageInitAs => :blImageInitAs,
      :blImageInitAsFromData => :blImageInitAsFromData,
      :blImageDestroy => :blImageDestroy,
      :blImageReset => :blImageReset,
      :blImageAssignMove => :blImageAssignMove,
      :blImageAssignWeak => :blImageAssignWeak,
      :blImageAssignDeep => :blImageAssignDeep,
      :blImageCreate => :blImageCreate,
      :blImageCreateFromData => :blImageCreateFromData,
      :blImageGetData => :blImageGetData,
      :blImageMakeMutable => :blImageMakeMutable,
      :blImageConvert => :blImageConvert,
      :blImageEquals => :blImageEquals,
      :blImageScale => :blImageScale,
      :blImageReadFromFile => :blImageReadFromFile,
      :blImageReadFromData => :blImageReadFromData,
      :blImageWriteToFile => :blImageWriteToFile,
      :blImageWriteToData => :blImageWriteToData,
    }
    args = {
      :blImageInit => [:pointer],
      :blImageInitMove => [:pointer, :pointer],
      :blImageInitWeak => [:pointer, :pointer],
      :blImageInitAs => [:pointer, :int, :int, :int],
      :blImageInitAsFromData => [:pointer, :int, :int, :int, :pointer, :int64, :int, :BLDestroyExternalDataFunc, :pointer],
      :blImageDestroy => [:pointer],
      :blImageReset => [:pointer],
      :blImageAssignMove => [:pointer, :pointer],
      :blImageAssignWeak => [:pointer, :pointer],
      :blImageAssignDeep => [:pointer, :pointer],
      :blImageCreate => [:pointer, :int, :int, :int],
      :blImageCreateFromData => [:pointer, :int, :int, :int, :pointer, :int64, :int, :BLDestroyExternalDataFunc, :pointer],
      :blImageGetData => [:pointer, :pointer],
      :blImageMakeMutable => [:pointer, :pointer],
      :blImageConvert => [:pointer, :int],
      :blImageEquals => [:pointer, :pointer],
      :blImageScale => [:pointer, :pointer, :pointer, :int],
      :blImageReadFromFile => [:pointer, :pointer, :pointer],
      :blImageReadFromData => [:pointer, :pointer, :ulong, :pointer],
      :blImageWriteToFile => [:pointer, :pointer, :pointer],
      :blImageWriteToData => [:pointer, :pointer, :pointer],
    }
    retvals = {
      :blImageInit => :uint,
      :blImageInitMove => :uint,
      :blImageInitWeak => :uint,
      :blImageInitAs => :uint,
      :blImageInitAsFromData => :uint,
      :blImageDestroy => :uint,
      :blImageReset => :uint,
      :blImageAssignMove => :uint,
      :blImageAssignWeak => :uint,
      :blImageAssignDeep => :uint,
      :blImageCreate => :uint,
      :blImageCreateFromData => :uint,
      :blImageGetData => :uint,
      :blImageMakeMutable => :uint,
      :blImageConvert => :uint,
      :blImageEquals => :int,
      :blImageScale => :uint,
      :blImageReadFromFile => :uint,
      :blImageReadFromData => :uint,
      :blImageWriteToFile => :uint,
      :blImageWriteToData => :uint,
    }
    symbols.each do |sym|
      begin
        attach_function apis[sym], sym, args[sym], retvals[sym]
      rescue FFI::NotFoundError => error
        $stderr.puts("[Warning] Failed to import #{sym} (#{error}).") if output_error
      end
    end
  end

end

